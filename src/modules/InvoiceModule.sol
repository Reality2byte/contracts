// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import { IModule } from "./../interfaces/IModule.sol";
import { IERC165 } from "openzeppelin-contracts/contracts/interfaces/IERC165.sol";
import { InvoiceModuleTypes } from "./../libraries/InvoiceModuleTypes.sol";
import { IContainer } from "./../interfaces/IContainer.sol";

contract InvoiceModule is IModule {
    mapping(address container => uint256[]) internal _invoicesOf;
    mapping(uint256 id => InvoiceModuleTypes.Invoice) internal _invoices;

    uint256 _nextInvoiceId;

    event InvoiceCreated(uint256 indexed invoiceId, InvoiceModuleTypes.Invoice invoice);

    error NotContainer();
    error InvalidPayer();
    error InvalidInvoiceId();
    error InvalidTimeInterval();

    /// @dev Allow only calls from contracts supporting the {IContainer} interface
    modifier onlyContainer() {
        if (!IERC165(msg.sender).supportsInterface(type(IContainer).interfaceId)) revert NotContainer();
        _;
    }

    function createInvoice(
        InvoiceModuleTypes.Invoice calldata invoice
    ) external onlyContainer returns (uint256 invoiceId) {
        // @todo add input sanitization
        // Checks: invoice values
        if (invoice.payer == address(0)) revert InvalidPayer();
        if (invoice.frequency == InvoiceModuleTypes.Frequency.Recurring && invoice.startTime == 0)
            revert InvalidTimeInterval();
        if (invoice.frequency == InvoiceModuleTypes.Frequency.Recurring && invoice.startTime >= invoice.endTime)
            revert InvalidTimeInterval();

        // Get the next invoice id
        invoiceId = _nextInvoiceId;

        // Effects: create the invoice
        _invoices[invoiceId] = InvoiceModuleTypes.Invoice({
            status: invoice.status,
            frequency: invoice.frequency,
            startTime: invoice.startTime,
            endTime: invoice.endTime,
            payer: invoice.payer,
            payment: InvoiceModuleTypes.Payment({
                recurrence: invoice.payment.recurrence,
                method: invoice.payment.method,
                amount: invoice.payment.amount,
                asset: invoice.payment.asset
            })
        });

        // Effects: increment the next invoice id
        // Use unchecked because the invoice id cannot realistically overflow
        unchecked {
            _nextInvoiceId = invoiceId + 1;
        }

        // Effects: add the invoice on the list of invoices generated by the container
        _invoicesOf[msg.sender].push(invoiceId);

        emit InvoiceCreated({ invoiceId: invoiceId, invoice: invoice });
    }

    function getInvoice(uint256 invoiceId) external view returns (InvoiceModuleTypes.Invoice memory invoice) {
        return _invoices[invoiceId];
    }

    function payInvoice(uint256 invoiceId) external payable {
        if (_invoices[invoiceId].payer == address(0)) revert InvalidInvoiceId();
    }
}
