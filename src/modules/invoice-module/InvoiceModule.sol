// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import { IERC165 } from "@openzeppelin/contracts/interfaces/IERC165.sol";
import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";

import { Types } from "./libraries/Types.sol";
import { Errors } from "./libraries/Errors.sol";
import { IInvoiceModule } from "./interfaces/IInvoiceModule.sol";
import { IContainer } from "./../../interfaces/IContainer.sol";

contract InvoiceModule is IInvoiceModule {
    using SafeERC20 for IERC20;

    /*//////////////////////////////////////////////////////////////////////////
                                  PRIVATE STORAGE
    //////////////////////////////////////////////////////////////////////////*/

    /// @dev Array with invoice IDs created through the `container` container contract
    mapping(address container => uint256[]) private _invoicesOf;

    /// @dev Invoice details mapped by the `id` invoice ID
    mapping(uint256 id => Types.Invoice) private _invoices;

    /// @dev Counter to keep track of the next ID used to create a new invoice
    uint256 private _nextInvoiceId;

    /*//////////////////////////////////////////////////////////////////////////
                                      MODIFIERS
    //////////////////////////////////////////////////////////////////////////*/

    /// @dev Allow only calls from contracts implementing the {IContainer} interface
    modifier onlyContainer() {
        if (!IERC165(msg.sender).supportsInterface(type(IContainer).interfaceId)) revert Errors.NotContainer();
        _;
    }

    /*//////////////////////////////////////////////////////////////////////////
                                CONSTANT FUNCTIONS
    //////////////////////////////////////////////////////////////////////////*/

    /// @inheritdoc IInvoiceModule
    function getInvoice(uint256 id) external view returns (Types.Invoice memory invoice) {
        return _invoices[id];
    }

    /*//////////////////////////////////////////////////////////////////////////
                                NON-CONSTANT FUNCTIONS
    //////////////////////////////////////////////////////////////////////////*/

    /// @inheritdoc IInvoiceModule
    function createInvoice(Types.Invoice calldata invoice) external onlyContainer returns (uint256 id) {
        // @todo add input sanitization
        // Checks: invoice values
        if (invoice.frequency == Types.Frequency.Recurring && invoice.startTime == 0)
            revert Errors.InvalidTimeInterval();
        if (invoice.frequency == Types.Frequency.Recurring && invoice.startTime >= invoice.endTime)
            revert Errors.InvalidTimeInterval();

        // Get the next invoice ID
        id = _nextInvoiceId;

        // Effects: create the invoice
        _invoices[id] = Types.Invoice({
            recipient: msg.sender,
            status: invoice.status,
            frequency: invoice.frequency,
            startTime: invoice.startTime,
            endTime: invoice.endTime,
            payment: Types.Payment({
                recurrence: invoice.payment.recurrence,
                method: invoice.payment.method,
                amount: invoice.payment.amount,
                asset: invoice.payment.asset
            })
        });

        // Effects: increment the next invoice id
        // Use unchecked because the invoice id cannot realistically overflow
        unchecked {
            _nextInvoiceId = id + 1;
        }

        // Effects: add the invoice on the list of invoices generated by the container
        _invoicesOf[msg.sender].push(id);

        emit InvoiceCreated({ id: id, invoice: invoice });
    }

    /// @inheritdoc IInvoiceModule
    function payInvoice(uint256 id) external payable {
        Types.Invoice memory invoice = _invoices[id];

        // Checks: the invoice is valid as all invoices must have the `endTime` field defined
        if (invoice.endTime == 0) revert Errors.InvalidInvoiceId();

        // Checks: the invoice is already paid or canceled
        if (invoice.status != Types.Status.Active)
            revert Errors.InvalidInvoiceStatus({ currentStatus: invoice.status });

        // Checks: the payment type is different than transfer
        if (invoice.payment.method != Types.Method.Transfer) revert Errors.InvalidPaymentType();

        // Effects: update the invoice status to `Paid`
        _invoices[id].status = Types.Status.Paid;

        // Checks: the payment must be done in native token (ETH) or an ERC-20 token
        if (invoice.payment.asset == address(0)) {
            // Interactions: pay the recipient with native token (ETH)
            (bool success, ) = payable(invoice.recipient).call{ value: invoice.payment.amount }("");
            if (!success) revert Errors.PaymentFailed();
        } else {
            // Interactions: pay the recipient with the ERC-20 token
            IERC20(invoice.payment.asset).safeTransfer({
                to: address(invoice.recipient),
                value: invoice.payment.amount
            });
        }
    }
}
